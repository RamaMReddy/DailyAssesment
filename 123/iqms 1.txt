learn about the different types of reviews.

Self Review
–
Self review is done by the developer before giving it to any other person for review.

Peer Review
–
Peer Review (Internal Quality Assurance - IQA) is done by any other member in the project.



100% of the project work items must undergo a Peer Review.

SME Review
–
SME Review (External Quality Assurance - EQA) is done by a Subject Matter Expert to bring an external perspective to work items that form the basis of the application/software product.

Requirements Specifications, Architecture, Design are recommended for the SME Review.

Complex or critical code components must be sampled for the SME review. Projects can define their own sampling criteria.

Customer deliverables, such as Software Requirements Specifications, User Manuals and Online Help are reviewed by Technical Communications Group as well.

Release Initiation Readiness Review
–
Review before a release or a program increment is initiated for an Agile Project. Review is done by the SME to check the readiness of the project team.

Iteration Review/Sprint Demo (External Quality Assurance - EQA)
–
Review recommended for the Product Increment (PI) at the end of an iteration or sprint. Review is done by the Product Owner/ Customer through a demo given by the development team.

PI Review/Release Demo (External Quality Assurance - EQA)
–
Review recommended at the end of a release or PI, through a demo given by the development team. Review is done by the Product Owner/Customer.




Unit Testing

Testing a single program or a set of programs
Can be done manually but is usually automated using tools, such as JUnit, QUnit, JSUnit and Selenium
It is a good practice to write the test cases before you write the code
Helps detect the errors early







Continuous Integration

Continuous Integration (CI) is a logical step in the development of an incremental integration strategy
This involves the installation of every piece of unit tested code in the integration environment as soon as it is ready
Tools, such as Ant, Nant, TestingWiz may be used for CI
 






Integration Testing

Testing the interfaces between programs
Verifies that the programs are compatible and fit together in the system

System Testing

Testing of the complete integrated - system to verify that it meets the specified functional and non-functional requirements
Tests for Functionality, Usability, Help Information, Security, Performance, Compatibility, Accessibility and Portability





User Acceptance Testing

Testing the developed system against the User requirements
Typically done by the User community
Tested in an environment that is similar to the Production environment

Regression Testing

Testing to verify that the previously tested software still performs the same way after it is changed
Changes include software enhancements, patches, defect fixes etc.
Done before moving the code to production



Performance Testing

Testing for software response time and stability under the expected workload
It also tests for system behavior for a large number of concurrent users
Some tools used are LoadRunner, LoadTest, Apache Jmeter, WebLOAD





Security Testing

Testing for software security e.g. authentication, authorization, availability, configuration, audit trails, data security, session management, client side attacks, buffer overflow, denial of service






Compatibility Testing

Testing to check that the software runs properly on different browsers, database, hardware, operating system, mobile devices and networks






Portability Testing

Testing to determine if the software can be moved from one environment to another






Usability Testing

Testing to check if the software is user friendly
Software usability is tested by checking flow, navigation, layout, content
Tests the ease of use and ease of learning





Accessibility Testing

Testing to check that the software is accessible and usable by people of different abilities i.e. visual, physical, hearing, cognitive and learning impairments
Some tools used are AccVerify, Bobby, WebXM, InFocus and Ramp Ascend





Globalization and Localization Testing

To verify that the software can run independently, irrespective of its geographical environment
These test for country-specific variations. Some examples include:
Language
Date and time formatting
Currency
Paper sizes for printing
Address and telephone number formatting
Zip Code formatting
Person name and titles
Regulatory compliance, such as privacy laws


Prepare for Testing
–
Write Test Scenarios and the corresponding Test Cases
Prepare Test Environment – hardware, system software, data, software under test and network
Prepare Test Data that will satisfy all scenarios
Perform the Testing
–
Run each test case by performing the test steps
Testing may be manual or automated through a tool
Record Test Results
–
Compare the observed system behavior with expected behavior
Record the observations and defects
Record Pass/Fail for each Test case
Verification and Re-Testing
–
After the defects are fixed, rerun the failed test cases
It is a good practice to run the full set of test cases for a clean run
For Agile projects, some of the defects may be recorded in the Product Backlog to track and close at a later stage


​Test Execution
–
These tools help in doing the Unit Testing, Regression Testing, Performance Testing, Device Testing and Accessibility Testing.
Some of these tools also help to find out the code coverage i.e. the parts of the code that have been tested.

Test Data Management
–
These tools help in creating large scale test data for performance testing and masking the sensitive test data.
Test Management
–
These tools help in maintaining the test cases corresponding to requirements, tracking defects, tracking the progress and status of testing.


Why do we need Software Configuration Management?
Any software system consists of a large number of components such as files, database definitions, scripts and documentation in the form of source code.

Such a system undergoes changes throughout its lifetime.

These changes could be due to defect fixes, maintenance or enhancements and could be assigned to multiple developers.

When multiple developers try to change the system for the work assigned to them, their changes could conflict with each other, or the developers could overwrite each other’s work.

Such uncontrolled changes destabilize the integrity of the system.

If these changes are moved to production, they could potentially cause widespread damage depending upon the system’s mission critical nature.

Hence, controlling changes to the system is a critical requirement to ensure stability and integrity of the application.

Further, the system evolves over time through regular maintenance and enhancements.

What is Software Configuration Management?

Software Configuration management is the process:

by which all the items in a project are uniquely identified, modified, stored and retrieved
to manage, track and control changes to every single item of the software system
to prevent any uncontrolled change that could cause system failure or instability
The Configuration management strategy in your project will help you to determine how the items are identified, how changes are handled and how different versions of the software are managed.

Click the button below to understand the key benefits of Software Configuration Management.

Configuration management practices help to: 

Ensure that a well-organized system is in place, where developers can refer to the past versions of work items and recreate previous states of the software system and its environment.

Make a change to any of the items and easily deploy the change to applicable environments – SIT, UAT or Production.

Merge work of one developer with that of the other developers and fix conflicts, if any, when multiple developers are changing the same set of files.

See each change made in any environment and trace it back to find out what the change was, when and why, and by whom, it was made.

Prevent unauthorized access to all project items.

What is a Configurable Item?
All items in a software system for which changes need to be tracked and versions need to be maintained are called Configurable items.

These are the set of components required to restore a system to a previous known state.

Typical Configurable items are:

Source code
Configuration information for hardware, software
Executables 
Data and data dictionaries
Test cases
Build and deployment Scripts
Project Plan
Requirement specification, Design document, Installation document and so on
Version Control systems are used to manage changes to the Configurable items and establish control on all changes in the software system.

Before we proceed, here's a quiz to check your understanding.

A Traceability Matrix is a crucial artifact that identifies the relationship among various components of a software system. It allows any software component to be traced back to the requirement.

Using a Traceability Matrix, you can identify all the impacted items while analyzing the changes to a requirement. 

There are three different types of Traceability Matrices that are used for impact analysis.

Click the tabs below to learn about them.

Horizontal Traceability helps to identify if a change in one requirement also impacts other requirements. 



For example: Change in one user requirement has an impact on another requirement in User Specification document OR change in the design of one component has an impact on another design component.

Vertical Traceability helps to trace corresponding items amongst the different work products throughout the software lifecycle. 



For example: You can trace a change in one requirement to its associated design components, code items, test scenarios and test cases.



Non-functional Requirements Traceability (NFR) helps to identify associated implementation components for changes in non-functional requirements like performance, security, usability. 

Tools for Configuration Management:::
Version Control system helps to track version history of all Configuration items, baseline a software system and so on. Here are a few examples:

Git
TFS
Subversion or SVN
Clearcase
Endevor (IBM Mainframe Systems)


Continuous Integration involves automated build and test and these are triggered by Continuous Integration Servers. Here are a few examples:

Jenkins
TeamCity
Travis CI
Bamboo
GitLab CI

